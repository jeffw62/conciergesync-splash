<!DOCTYPE html>
<html lang="en">
<head>
  <style>
  /* Hide the console and its tabs on the splash page */
  body.splash-mode #cs-console,
  body.splash-mode .cs-tabs {
    display: none !important;
  }
</style>
  <link rel="dns-prefetch" href="//portal.conciergesync.ai">
  <link rel="preconnect" href="https://portal.conciergesync.ai" crossorigin>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ConciergeSync™ Beta Access</title>
  <style>
    :root {
      --card: #fff;
      --ink: #0f172a;
      --muted: #475569;
      --bg: #f6f7fb;
      --accent: #111;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      line-height: 1.6;
    }
    /* Step 1: touch friction fix */
.cs-tile {
  touch-action: pan-y;
  -webkit-tap-highlight-color: transparent;
}
/* Touch: allow vertical scroll, but keep first-swipe dismiss solid */
.cs-tile, .cs-tile * {
  touch-action: pan-y;
  -webkit-tap-highlight-color: transparent;
}

    .container { max-width: 880px; margin: 40px auto; padding: 0 20px; }

    .card {
      background: var(--card);
      border: 1px solid #e6eaf0;
      border-radius: 16px;
      box-shadow: 0 6px 24px rgba(15, 23, 42, 0.06);
      padding: 28px;
      margin-bottom: 24px;
    }

    h1 { font-size: 34px; line-height: 1.2; text-align: center; margin-bottom: 8px; }
    h2 { font-size: 22px; margin: 18px 0; text-align: center; }
    h3 { font-size: 18px; margin: 16px 0 10px; }

    p, li { color: var(--muted); }
    ul { margin: 8px 0 0 24px; }

    .centered { text-align: center; }

    .cta-button {
      display: inline-block;
      padding: 14px 24px;
      border-radius: 12px;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      text-decoration: none;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }
    .cta-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.18);
    }
    /* Splash: hide the top-right X */
body.splash-mode #exitConsole,
body.splash-mode .console-exit {
  display: none !important;
}
    /* Default: open tiles are LARGE; small only in Arrange mode */
#cs-console:not(.arrange-on) .cs-tile {
  width: 380px !important;
  min-width: 380px !important;
  max-width: 92vw;
  height: min(78vh, 760px) !important;
}
  /* default: keep console hidden */
.console { display: none; }

/* when entering console mode, hide landing hero and show console UI */
.console-mode .hero,
.console-mode .intro,
.console-mode .welcome { display: none !important; }
.console-mode .console { display: block !important; }

  </style>
</head>
<body>

  <script>
(() => {
  const qs = new URLSearchParams(location.search);
  if (qs.get('enter') === '1') {
    // mark authed so no redirect back to auth.html
    sessionStorage.setItem('cs_authed','1');
    localStorage.setItem('cs_authed','1');
    document.cookie = "cs_auth=1; path=/; max-age=7200; SameSite=Lax";

    // carry uid/email for later use (optional)
    const uid = qs.get('uid') || '', email = qs.get('email') || '';
    if (uid)   { sessionStorage.setItem('cs_uid', uid);   localStorage.setItem('cs_uid', uid); }
    if (email) { sessionStorage.setItem('cs_email', email); localStorage.setItem('cs_email', email); }

    // swap to console view immediately
    document.documentElement.classList.add('console-mode');

    // open a default tile once DOM is ready
    const open = qs.get('open') || 'overview';
    const openNow = () => {
      if (window.openConsole) { window.openConsole(open); return; }
      const sel = `[data-open="${open}"], [data-tile-open="${open}"], .open-${open}`;
      document.querySelector(sel)?.dispatchEvent(new Event('click', { bubbles: true }));
    };
    requestAnimationFrame(openNow);
    setTimeout(openNow, 200); // safety in case UI mounts a beat later
  }
})();
</script>

  <body class="splash-mode">
  <div class="container">
    <!-- Hero Card -->
    <div class="card welcome">
      <h1>Welcome to ConciergeSync™</h1>
      <p class="centered">Your personal travel rewards strategist — earn, manage, and redeem points with clarity.</p>
    </div>

    <!-- Why / Role / Value -->
    <div class="section">
      <div class="card">
        <h2>Place Holder</h2>
        <p style="margin:0 0 12px;color:#444;">
          <strong>Place Holder
        </p>
        <p style="margin:0 0 12px;color:#444;">
          Place Holder
        </p>
        <p style="margin:0 0 12px;color:#444;">
          Place Holder
        </p>
        <p style="margin:0 0 20px;color:#444;">
          Place Holder
        </p>

        <h3 style="margin:12px 0 8px;">Your Role as a Beta User Client (BUC)</h3>
        <ul style="margin:0 0 14px 22px;">
          <li><strong>Onboard (5–7 min):</strong> share your travel goals and programs.</li>
          <li><strong>Explore ConciergeSync™ as it evolves:</strong> we’ll invite you to test features as they’re released and sanity-check how they work.</li>
          <li><strong>Give quick feedback:</strong> if something’s confusing or off, reply to our 2–3 min prompts (we’ll ping you).</li>
        </ul>

        <h3 style="margin:8px 0 8px;">How This Helps ConciergeSync™</h3>
        <ul style="margin:0 0 14px 22px;">
          <li>Validate our true-cost math (fees, surcharges, effective miles burned).</li>
          <li>Surface airline/partner quirks (phantom space, mixed cabins, transfer timing).</li>
          <li>Prioritize the roadmap around what actually saves you time or money.</li>
          <li>Harden reliability across devices, emails, and real booking flows.</li>
        </ul>

        <h3 style="margin:8px 0 8px;">What You Get for Helping Us Build ConciergeSync™</h3>
        <ul style="margin:0 0 6px 22px;">
          <li><strong>Lifetime access</strong> — all premium upgrades included.*</li>
          <li>Early access to new features & partner integrations.</li>
          <li>Priority support and a direct line to the team.</li>
        </ul>
        <p style="margin:10px 0 0;color:#777;font-size:.9rem;">
          *Lifetime access limited to one account per user. No bank logins required; you can opt out anytime.
        </p>
      </div>
    </div>

    <!-- CTA Button -->
    <div class="centered" style="margin-top: 40px;">
      <h2>Ready to join the beta?</h2>
      <a href="/beta/02-agree.html" class="cta-button">Begin Your ConciergeSync™ Journey</a>
    </div>
  </div>

<!-- Pre-warm the portal to avoid cold starts -->
<script>
(function () {
  try {
    var img = new Image();
    img.referrerPolicy = 'no-referrer';
    img.src = 'https://portal.conciergesync.ai/health?ts=' + Date.now();
  } catch (e) {}
})();
</script>

<!-- ============= CONSOLE BACKDROP + FULLSCREEN CONTROLS ============= -->
<!-- Controls -->
<a id="enterConsole" class="console-btn" href="#">Enter Console</a>
<script>
  // attach right after the button
  document.getElementById('enterConsole')?.addEventListener('click', function (e) {
    e.preventDefault();
    // mark authed so guards don’t bounce to auth.html
    sessionStorage.setItem('cs_authed','1');
    localStorage.setItem('cs_authed','1');
    document.cookie = "cs_auth=1; path=/; max-age=7200; SameSite=Lax";

    // swap to console view
    document.documentElement.classList.add('console-mode');

    // open your default tile
    if (window.openConsole) {
      window.openConsole('overview');
    } else {
      const el = document.querySelector('[data-open="overview"], [data-tile-open="overview"], .open-overview');
      el?.dispatchEvent(new Event('click', { bubbles: true }));
    }
  });
</script>

<button id="exitConsole"
        class="console-exit"
        aria-label="Exit Console"
        type="button"
        onclick="window.location.href='exit.html'">×</button>


<!-- Backdrop layers (sit behind your glass tiles) -->
<div id="csBackdrop" class="backdrop">
  <div class="backdrop-image" id="backdropImage"></div>
  <div class="backdrop-overlay" id="backdropOverlay"></div>
</div>

<style id="cs-console-styles">
  :root{
    /* Theme vars */
    --bg-brightness: 1.15;   /* base lift */
    --bg-contrast: 1.05;
    --overlay: 0.28;         /* auto-tuned per image */
    --overlay-grad-top: rgba(0,0,0,0.35);
    --overlay-grad-bottom: rgba(0,0,0,0.55);
    --vh: 100vh;             /* fixed on iOS */
    --z-ui: 4000;            /* ensure buttons sit above your tiles */

    /* Calm motion vars — single source of truth */
    --cs-time: 640ms;                               /* general motion */
    --cs-time-out: 900ms;                           /* dismiss/exit slower */
    --cs-ease: cubic-bezier(.22, 1, .36, 1);        /* mellow ease-out */

    /* Backdrop reveal */
    --bg-blur: 6px;          /* start slightly soft */
    --bg-scale: 1.03;        /* start slightly zoomed */
  }

  /* Respect reduced motion users */
  @media (prefers-reduced-motion: reduce){
    :root{
      --cs-time: 0ms;
      --cs-time-out: 0ms;
    }
  }

  /* Backdrop fills the viewport and lives under your content */
  .backdrop{
    position: fixed;
    inset: 0;
    width: 100%;
    height: var(--vh);
    overflow: hidden;
    z-index: 0;
  }
  .backdrop-image{
    position: absolute;
    inset: 0;
    background-position: center center;
    background-size: cover;
    filter: brightness(var(--bg-brightness)) contrast(var(--bg-contrast)) blur(var(--bg-blur));
    transform: scale(var(--bg-scale)) translateZ(0); /* promote to its own layer */
    will-change: transform, opacity, filter;
    transition: opacity 600ms ease, transform 900ms ease, filter 900ms ease;
    opacity: 0; /* start hidden */
  }
  .backdrop-overlay{
    position: absolute;
    inset: 0;
    pointer-events: none;
    background:
      linear-gradient(to bottom,
        var(--overlay-grad-top),
        var(--overlay-grad-bottom));
    opacity: var(--overlay);
    transition: opacity 220ms ease;
  }

  /* Console buttons */
  .console-btn{
    position: fixed;
    bottom: 24px;
    right: 24px;
    z-index: var(--z-ui);
    padding: 12px 16px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.35);
    background: rgba(20,20,20,0.45);
    backdrop-filter: blur(8px) saturate(1.1);
    color: #fff;
    font-weight: 600;
    cursor: pointer;
  }
  .console-btn:hover{ background: rgba(20,20,20,0.6); }

  .console-exit{
    position: fixed;
    top: 18px;
    right: 18px;
    z-index: var(--z-ui);
    width: 40px; height: 40px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.35);
    background: rgba(20,20,20,0.45);
    color: #fff;
    font-size: 28px; line-height: 36px;
    text-align: center;
    cursor: pointer;
    backdrop-filter: blur(8px) saturate(1.1);
  }
  .console-exit:hover{ background: rgba(20,20,20,0.6); }

  /* Pseudo-fullscreen on iOS */
  .pseudo-fullscreen{
    position: fixed;
    inset: 0;
    width: 100%;
    height: var(--vh);
    overflow: hidden;
    background: #000;
  }

  /* When in console mode, hide the Enter button, show Exit */
  .in-console #enterConsole{ display: none; }
  .in-console #exitConsole{ display: inline-block; }

  /* Immersive console mode */
.in-console .container {
  opacity: 0;
  pointer-events: none;
  transition: opacity 250ms ease;
}

  /* Backdrop reveal when console enters */
  .in-console .backdrop-image { opacity: 1; }
  .in-console{
    --bg-blur: 0px;
    --bg-scale: 1.00;
  }

  /* Ensure the close button stays readable */
  .in-console .console-exit {
    box-shadow: 0 2px 10px rgba(0,0,0,.35);
    border-color: rgba(255,255,255,.5);
  }
</style>

<script id="cs-console-script">
(function(){
  // ====== CONFIG: add/adjust your images here ======
  const IMAGES = ['/beta/assets/bg/IMG_5374.jpeg'];

  // ====== Helpers ======
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  function setVhVar(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh*100}px`);
  }
  setVhVar();
  window.addEventListener('resize', setVhVar);

  function pickImage(){
    const last = Number(localStorage.getItem('last_bg_idx') ?? '-1');
    let idx = Math.floor(Math.random() * IMAGES.length);
    if (IMAGES.length > 1 && idx === last) idx = (idx + 1) % IMAGES.length;
    localStorage.setItem('last_bg_idx', String(idx));
    return IMAGES[idx];
  }

  function preload(src){
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = src;
    return img;
  }

  function estimateLuminance(imgEl){
    try{
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = 64;
      const h = canvas.height = 64;
      ctx.drawImage(imgEl, 0, 0, w, h);
      const data = ctx.getImageData(0,0,w,h).data;
      let sum = 0, count = 0;
      for(let i=0;i<data.length;i+=4){
        const r = data[i], g = data[i+1], b = data[i+2];
        const y = 0.2126*r + 0.7152*g + 0.0722*b; // Rec.709
        sum += y; count++;
      }
      return sum / count; // 0..255
    }catch(e){
      return 140; // safe mid if cross-origin blocks canvas
    }
  }

  function setOverlayForLuma(luma){
    // brighter image => stronger overlay
    const t = Math.min(1, Math.max(0, (luma - 110) / (220 - 110)));
    const opacity = 0.22 + (0.42 - 0.22)*t; // 0.22..0.42
    document.documentElement.style.setProperty('--overlay', opacity.toFixed(3));
  }

  // ====== Apply background ======
  const backdropImage = document.getElementById('backdropImage');
  const chosenSrc = pickImage();
  const img = preload(chosenSrc);
  img.onload = () => {
    backdropImage.style.backgroundImage = `url("${chosenSrc}")`;
    setOverlayForLuma(estimateLuminance(img));
  };

  // ====== Fullscreen / Console Mode ======
  const enterBtn = document.getElementById('enterConsole');
  const exitBtn  = document.getElementById('exitConsole');

  function enterConsole(){
    document.body.classList.add('in-console');
    const rootEl = document.documentElement;
    if (!isIOS && rootEl.requestFullscreen) {
      rootEl.requestFullscreen()
        .then(()=>{ exitBtn.hidden = false; })
        .catch(()=>{
          document.documentElement.classList.add('pseudo-fullscreen');
          exitBtn.hidden = false;
        });
    } else {
      document.documentElement.classList.add('pseudo-fullscreen');
      exitBtn.hidden = false;
    }
  }

  function exitConsole(){
    document.body.classList.remove('in-console');
    exitBtn.hidden = true;
    document.documentElement.classList.remove('pseudo-fullscreen');
    if (document.fullscreenElement) document.exitFullscreen();
  }

  if (enterBtn && enterBtn.tagName !== 'A') {
  enterBtn.addEventListener('click', enterConsole);
}
  exitBtn.addEventListener('click', exitConsole);
  window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') exitConsole(); });
})();
</script>
<!-- ========================== /END CONSOLE BLOCK ========================== -->

<!-- ===================== TILE CONSOLE (centered, sliding, swipe-to-dismiss) ===================== -->
<div id="cs-console">
  <!-- Tabs -->
  <div class="cs-tabs" aria-label="Console Tabs">
    <button class="cs-tab" data-key="overview">Overview</button>
    <button class="cs-tab" data-key="itinerary">Itinerary</button>
    <button class="cs-tab" data-key="values">Value Calc</button>
  </div>

  <!-- Tiles area -->
  <div id="cs-tiles" class="cs-tiles" aria-live="polite">
  </div>
</div>

<style>
/* Layout */
#cs-console{
  position: absolute; inset: 0;
  display: grid; grid-template-rows: auto 1fr;
  padding: 24px; pointer-events: auto;
  z-index: 10; /* keep this above backdrop */
}

/* Tabs */
.cs-tabs{
  display: flex; justify-content: center; gap: 10px;
  padding: 10px 12px;
  backdrop-filter: blur(8px) saturate(1.1);
  background: rgba(20,20,20,.3);
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.25);
  width: max-content; margin: 0 auto 14px;
}
.cs-tab{
  padding: 10px 14px; border-radius: 10px;
  color: #fff; background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.18);
  cursor: pointer; font-weight: 600;
}
.cs-tab:hover{ background: rgba(255,255,255,.12); }

/* Tiles grid: center rows, wrap when needed */
.cs-tiles{
  position: relative;
  display: grid;
  grid-auto-flow: row dense;
  grid-auto-rows: 1fr;
  grid-template-columns: repeat(auto-fit, minmax(320px, 420px));
  gap: 18px;
  justify-content: start;
  align-content: start;
  height: 100%;
  overflow: visible;              /* remove inner scrollbar */
  scrollbar-gutter: auto;         /* reset from stable */
  padding: 6px;
}
/* Center a single tile perfectly */
.cs-tiles.single{
  grid-template-columns: minmax(360px, 520px);
  justify-content: center;
}

/* Tile (glass) */
.cs-tile{
  /* perf hints */
  will-change: transform, opacity;
  transform: translateZ(0);

  /* look */
  background: rgba(255,255,255,.12);
  border: 1px solid rgba(255,255,255,.28);
  border-radius: 18px;
  box-shadow: 0 10px 30px rgba(0,0,0,.18);
  backdrop-filter: blur(12px) saturate(1.2);
  color: #f5f7fb;

  /* layout */
  display: grid; 
  grid-template-rows: auto 1fr;
  min-height: 260px; 
  max-height: 65vh;
  overflow: hidden;

  /* entry animation disabled to remove flicker */
  transform: none;
  opacity: 1;
  animation: none;

  /* touch: allow vertical scroll; horizontal is ours */
  touch-action: pan-y;
  -webkit-tap-highlight-color: transparent;

  /* default: no tween; handlers add when needed */
  transition: none;
}

/* Focused tile: a touch brighter with a soft lift */
.cs-tile.is-focused{
  box-shadow: 0 16px 44px rgba(0,0,0,.28),
              0 0 0 1px rgba(255,255,255,.20) inset;
  backdrop-filter: blur(12px) saturate(1.25);
  transform: translateZ(0);
}

/* While FLIP is running or you're swiping, lighten effects for smoothness */
.cs-tile.moving,
.cs-tile.cs-swiping{
  backdrop-filter: blur(8px) saturate(1.1);
  box-shadow: 0 8px 22px rgba(0,0,0,.16);
}

/* Smooth swipe-away when we commit the dismiss (calm timing) */
.cs-tile.cs-dismissing{
  transition: transform var(--cs-time-out) var(--cs-ease),
              opacity   var(--cs-time-out) var(--cs-ease);
  opacity: 0;
}

/* Kill the settle pulse */
@keyframes cs-land {
  0%   { transform: none; }
  100% { transform: none; }
}
.cs-free .cs-tile.cs-landing {
  animation: cs-land 420ms cubic-bezier(.22, 1, .36, 1);
}

/* Entrance pop (kept minimal to avoid flicker) */
@keyframes cs-pop { 0% { opacity: 0; } 100% { opacity: 1; } }

/* Close (X) animation */
.cs-exit{ animation: cs-exit var(--cs-time) var(--cs-ease) forwards; }
@keyframes cs-exit{ to { opacity: 0; transform: translateY(8px) scale(.96); } }

.cs-tile-head{
  display: flex; align-items: center; justify-content: space-between;
  padding: 12px 14px; background: rgba(0,0,0,.18);
  border-bottom: 1px solid rgba(255,255,255,.18);
}
.cs-tile-head h4{ margin: 0; font-size: 15px; font-weight: 700; letter-spacing:.2px; }
.cs-close{
  width: 30px; height: 30px; border-radius: 8px;
  background: rgba(255,255,255,.12);
  color: #fff; border: 1px solid rgba(255,255,255,.25);
  cursor: pointer; font-size: 18px; line-height: 28px; text-align:center;
}
.cs-close:hover{ background: rgba(255,255,255,.2); }
.cs-tile-body{ padding: 14px; overflow: auto; }

/* Free-mode: tiles are freely placed and draggable (JS will toggle .cs-free) */
#cs-console.cs-free .cs-tiles {
  position: relative;
  scrollbar-gutter: stable both-edges;
}
#cs-console.cs-free .cs-tile  {
  position: absolute;
  left: var(--x, 0px);
  top:  var(--y, 0px);
  will-change: left, top, transform;
  transition: transform var(--cs-time) var(--cs-ease), box-shadow 180ms ease;
  touch-action: none; /* handler captures both X & Y during drag */
}

/* Swipe feedback defaults */
.cs-swiping{ transition: none !important; }

/* Ensure the tiles themselves can still receive taps */
.cs-tile,
.cs-tile *{ pointer-events: auto; }

/* Let FLIP handle grid movement; our entry animation just fades */
.cs-tile{ transform: none; }

/* Fix free-mode: use left/top only; avoid double-transform drift */
.cs-free .cs-tile{
  transform: none;       /* allow cs-land animation to run */
  left: var(--x, 0px);
  top:  var(--y, 0px);
}
  /* Optional: show grabbing immediately on press */
  .cs-tile:active,
  .cs-tile.cs-swiping { cursor: grabbing; }
  
  /* Cursor hints */
  .cs-tile { cursor: grab; }
  .cs-free .cs-tile.cs-swiping { cursor: grabbing; }
  
</style>

<script>
(()=>{
  const tabs      = document.querySelectorAll('.cs-tab');
  const tilesWrap = document.getElementById('cs-tiles');
  const consoleEl = document.getElementById('cs-console');

  // Hide/remove any legacy Arrange UI that might sneak in
  (function killArrange(){
    consoleEl?.classList.remove('arrange-on');
    const css = document.createElement('style');
    css.textContent = '#arrangeToggle{display:none!important}';
    document.head.appendChild(css);
    document.getElementById('arrangeToggle')?.remove();
  })();

  function updateWrapClass(){
    const count = tilesWrap.querySelectorAll('.cs-tile').length;
    tilesWrap.classList.toggle('single', count === 1);
  }

  // FLIP helper
  function flipAnimate(container, changeDomSync){
    const REDUCED = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (REDUCED) { changeDomSync(); return; }

    const children = Array.from(container.children);
    const first = new Map();
    children.forEach(el => first.set(el, el.getBoundingClientRect()));

    changeDomSync();

    const last = new Map();
    Array.from(container.children).forEach(el => last.set(el, el.getBoundingClientRect()));

    last.forEach((rLast, el) => {
      const rFirst = first.get(el);
      if (!rFirst) return;
      const dx = rFirst.left - rLast.left;
      const dy = rFirst.top  - rLast.top;
      if (dx || dy) {
        el.style.willChange = 'transform';
        el.style.transition = 'transform 0s';
        el.style.transform = `translate(${dx}px, ${dy}px)`;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            el.style.transition = 'transform var(--cs-time) var(--cs-ease)';
            el.style.transform = '';
            el.addEventListener('transitionend', () => {
              el.style.transition = '';
              el.style.willChange = '';
            }, { once: true });
          });
        });
      }
    });
  }

  // Calm dismiss
  function calmDismiss(tile, direction = 1){
    const off = (window.innerWidth * 0.5) * direction; // 50vw
    tile.classList.add('cs-dismissing');
    tile.style.transform = `translateX(${off}px) rotate(${off*0.002}deg)`;
    tile.addEventListener('transitionend', () => {
      tile.remove();
      updateWrapClass();
    }, { once: true });
  }

  // Outside click/backdrop → dismiss focused tile
  const backdropEl = document.querySelector('#csBackdrop, .backdrop');
  function isOutsideConsole(target){ return consoleEl && !consoleEl.contains(target); }
  if (backdropEl) {
    backdropEl.addEventListener('pointerdown', (e) => {
      const active = document.querySelector('.cs-tile.is-focused');
      if (!active) return;
      calmDismiss(active, (e.clientX >= window.innerWidth/2) ? 1 : -1);
    });
  }
  window.addEventListener('pointerdown', (e) => {
    if (!isOutsideConsole(e.target)) return;
    const active = document.querySelector('.cs-tile.is-focused');
    if (!active) return;
    calmDismiss(active, (e.clientX >= window.innerWidth/2) ? 1 : -1);
  }, { capture: true });

  const openKeys = new Set();

  const TILE_TEMPLATES = {
    overview: () => `
      <header class="cs-tile-head">
        <h4>Overview</h4>
        <button class="cs-close" aria-label="Close">×</button>
      </header>
      <div class="cs-tile-body"><p>Overview content goes here.</p></div>`,
    itinerary: () => `
      <header class="cs-tile-head">
        <h4>Itinerary</h4>
        <button class="cs-close" aria-label="Close">×</button>
      </header>
      <div class="cs-tile-body"><p>Trip segments, dates, carriers.</p></div>`,
    values: () => `
      <header class="cs-tile-head">
        <h4>Value Calc</h4>
        <button class="cs-close" aria-label="Close">×</button>
      </header>
      <div class="cs-tile-body"><p>CPP, cash vs award, transfer hints.</p></div>`
  };

  // Enter free mode and freeze current grid positions into --x/--y
  function enableFreeMode(){
    if (consoleEl.classList.contains('cs-free')) return;
    consoleEl.classList.add('cs-free');
    const gridRect = tilesWrap.getBoundingClientRect();
    Array.from(tilesWrap.children).forEach(tile => {
      const r = tile.getBoundingClientRect();
      const x = r.left - gridRect.left + tilesWrap.scrollLeft;
      const y = r.top  - gridRect.top  + tilesWrap.scrollTop;
      tile.style.setProperty('--x', x + 'px');
      tile.style.setProperty('--y', y + 'px');
    });
  }

  function applyOrder(){
    const keys = Array.from(openKeys);
    const focused = keys.slice(-2); // keep last two centered together
    flipAnimate(tilesWrap, () => {
      focused.forEach(k => {
        const el = tilesWrap.querySelector(`.cs-tile[data-key="${k}"]`);
        if (el) tilesWrap.appendChild(el);
      });
    });
  }

  function closeTile(el){
    const key = el.dataset.key;
    el.classList.add('cs-exit');
    el.addEventListener('animationend', () => {
      flipAnimate(tilesWrap, () => {
        if (openKeys.has(key)) openKeys.delete(key);
        el.remove();
      });
      applyOrder();
      updateWrapClass();
    }, { once: true });
  }

// Natural drag (press→move→release).
// Softer *start drag* + slightly firmer *whisk-to-dismiss* (left & right).
function addTileHandlers(tile){
  // X closes
  tile.querySelector('.cs-close')?.addEventListener('click', () => closeTile(tile));

  // ── Tunables ───────────────────────────────────────────────────────────
const SLOP = 2;               // (unchanged)
const PRESS_TO_DRAG_MS = 90;  // ↓ was 120 — starts drag sooner
const H_ANGLE = 60;           // (unchanged)
const FLICK_V = 0.22;         // ↑ was 0.20 — slightly firmer swipe speed
const DISMISS_MIN = 36;       // (unchanged)
const DISMISS_FRAC = 0.12;    // ↑ was 0.10 — slightly longer swipe distance
const COMMIT_FRAC = 0.45;     // (unchanged)

  let isDown=false, activeId=null, mode=null; // null|'drag'|'swipe'
  let t0=0, startX=0, startY=0, lastX=0, lastY=0, baseX=0, baseY=0;
  let pressTimer=null;

  // recent positions to measure instantaneous velocity (~120ms window)
  let trail = []; // [{t, x}]

  const getVar = (name, el=tile) => {
    const v = getComputedStyle(el).getPropertyValue(name);
    return v.trim()==='' ? NaN : parseFloat(v);
  };
  const clamp = (n, a, b)=>Math.max(a, Math.min(b, n));
  // angle to the horizontal axis (direction-agnostic: left or right)
  const hdeg = (dx,dy)=>Math.atan2(Math.abs(dy), Math.abs(dx)) * 180/Math.PI;
  const dismissPx = () => Math.max(DISMISS_MIN, tile.offsetWidth * DISMISS_FRAC);

  function beginDrag(){
    // ensure free-mode & capture starting offsets
    enableFreeMode();
    const wrapRect = tilesWrap.getBoundingClientRect();
    const r = tile.getBoundingClientRect();
    const vx = getVar('--x'), vy = getVar('--y');

    baseX = Number.isNaN(vx) ? (r.left - wrapRect.left + tilesWrap.scrollLeft) : vx;
    baseY = Number.isNaN(vy) ? (r.top  - wrapRect.top  + tilesWrap.scrollTop) : vy;

    tile.classList.add('is-focused','cs-swiping');
    tile.style.transition = 'none';
    tile.style.transform  = 'none';
  }

  function onDown(e){
    if ('button' in e && e.button !== 0) return;
    if (e.target.closest('.cs-close,button,a,input,textarea,select')) return;

    isDown   = true;
    activeId = e.pointerId ?? null;
    t0 = performance.now();

    startX = lastX = e.clientX;
    startY = lastY = e.clientY;
    mode   = null;
    trail  = [{ t: t0, x: startX }];

    // Short press → auto-enter drag (feels "less holdy")
    clearTimeout(pressTimer);
    pressTimer = setTimeout(() => {
      if (!mode && isDown) { mode='drag'; beginDrag(); }
    }, PRESS_TO_DRAG_MS);

    try { tile.setPointerCapture?.(activeId); } catch {}
    if (e.cancelable) e.preventDefault();
  }

  function onMove(e){
    if (!isDown) return;
    if (activeId!=null && e.pointerId!=null && e.pointerId!==activeId) return;

    lastX = e.clientX; lastY = e.clientY;
    const dx = lastX - startX;
    const dy = lastY - startY;
    const dist = Math.hypot(dx,dy);

    // record trail (keep last ~120ms)
    const now = performance.now();
    trail.push({ t: now, x: lastX });
    while (trail.length && now - trail[0].t > 120) trail.shift();
    const vxRecent = (() => {
      if (trail.length < 2) return 0;
      const a = trail[0], b = trail[trail.length-1];
      return Math.abs(b.x - a.x) / Math.max(1, b.t - a.t); // px/ms
    })();

    // Decide gesture
    if (!mode){
      if (dist < SLOP) return;
      clearTimeout(pressTimer); // movement decides, not the timer

      const angle = hdeg(dx,dy);
      const thr   = dismissPx();

      // mostly horizontal + (fast OR already ~30% of threshold) => swipe
      if (angle <= H_ANGLE && (vxRecent > FLICK_V || Math.abs(dx) > thr * 0.3)){
        mode = 'swipe';
      } else {
        mode = 'drag';
        beginDrag();
      }
    }

    if (mode === 'swipe'){
      if (e.cancelable) e.preventDefault();
      tile.classList.add('cs-swiping');
      const thr = dismissPx();
      const fade = Math.min(0.7, Math.abs(dx) / (thr * 0.9)); // gentle, earlier fade
      tile.style.transform = `translateX(${dx}px) rotate(${dx*0.008}deg)`;
      tile.style.opacity   = String(1 - fade);
      return;
    }

    // drag
    if (e.cancelable) e.preventDefault();
    const maxX = tilesWrap.scrollWidth  - tile.offsetWidth;
    const maxY = tilesWrap.scrollHeight - tile.offsetHeight;
    const nx = clamp(baseX + dx, 0, Math.max(0, maxX));
    const ny = clamp(baseY + dy, 0, Math.max(0, maxY));
    tile.style.setProperty('--x', nx + 'px');
    tile.style.setProperty('--y', ny + 'px');
  }

  function onUp(){
    if (!isDown) return;
    isDown = false;

    clearTimeout(pressTimer);
    try { if (activeId!=null) tile.releasePointerCapture?.(activeId); } catch {}
    activeId = null;

    tile.classList.remove('cs-swiping','is-focused');

    const dx = lastX - startX;
    const now = performance.now();
    while (trail.length && now - trail[0].t > 120) trail.shift();
    const vxRecent = (() => {
      if (trail.length < 2) return 0;
      const a = trail[0], b = trail[trail.length-1];
      return Math.abs(b.x - a.x) / Math.max(1, b.t - a.t);
    })();
    const thr = dismissPx();

    if (mode === 'swipe'){
      // Commit if far OR fast (slightly firmer than last build)
      if (Math.abs(dx) >= thr * COMMIT_FRAC || vxRecent >= FLICK_V){
        calmDismiss(tile, dx>=0?1:-1);
      } else {
        tile.style.transition = `transform var(--cs-time) var(--cs-ease), opacity var(--cs-time) var(--cs-ease)`;
        tile.style.transform = '';
        tile.style.opacity = '';
        tile.addEventListener('transitionend', () => { tile.style.transition=''; }, { once:true });
      }
    } else if (mode === 'drag'){
      tile.style.transition = '';
      tile.style.transform  = 'none';
    }
    mode = null;
    trail.length = 0;
  }

  tile.addEventListener('pointerdown', onDown, { passive:false });
  window.addEventListener('pointermove', onMove,  { passive:false });
  window.addEventListener('pointerup',   onUp);
  window.addEventListener('pointercancel', onUp);
}

function openTile(key){
  const existing = tilesWrap.querySelector(`.cs-tile[data-key="${key}"]`);
  if (existing){
    openKeys.delete(key);
    openKeys.add(key);
    applyOrder();
    updateWrapClass();
    existing.focus?.({preventScroll:true});
    return;
  }

  const sec = document.createElement('section');
  sec.className = 'cs-tile';
  sec.dataset.key = key;
  sec.innerHTML = (TILE_TEMPLATES[key] || (()=>`
    <header class="cs-tile-head">
      <h4>${key}</h4>
      <button class="cs-close" aria-label="Close">×</button>
    </header>
    <div class="cs-tile-body"><p>${key} tile.</p></div>`))();

  addTileHandlers(sec);

  // Append via FLIP (keeps grid calm if you're not in free mode yet)
  flipAnimate(tilesWrap, () => {
    openKeys.add(key);
    tilesWrap.appendChild(sec);
    updateWrapClass();
  });

  // 🔸 Ensure FREE MODE on first open, then center & lightly cascade
  if (!consoleEl.classList.contains('cs-free')) {
    enableFreeMode(); // freezes current grid positions to --x/--y
  }
  // Center the NEW tile and offset slightly so multiple don't stack
  requestAnimationFrame(() => {
    const wrapRect = tilesWrap.getBoundingClientRect();
    const r = sec.getBoundingClientRect();
    const count  = tilesWrap.querySelectorAll('.cs-tile').length;
    const offset = (count - 1) * 24; // 24px cascade

    const x = tilesWrap.scrollLeft + Math.max(0, (wrapRect.width  - r.width )/2 + offset);
    const y = tilesWrap.scrollTop  + Math.max(0, (wrapRect.height - r.height)/2 + offset);

    sec.style.setProperty('--x', x + 'px');
    sec.style.setProperty('--y', y + 'px');
    sec.style.transform = 'none';
  });

  sec.focus?.({ preventScroll: true });
}
  // Tabs: immediate fire
  tabs.forEach((btn) => {
    const onTap = (e) => {
      if (e.pointerType === 'touch' || e.pointerType === 'pen') e.preventDefault();
      openTile(btn.dataset.key);
    };
    btn.addEventListener('pointerdown', onTap, { passive:false });
    btn.addEventListener('click', (e) => onTap(e));
  });

  // Wire any pre-rendered tiles
  document.querySelectorAll('.cs-tile').forEach(addTileHandlers);
  updateWrapClass();
})();
</script>
<!-- =================== /END TILE CONSOLE =================== -->
<script>
(function () {
  // Only run on the splash page (where the button exists)
  var btn = document.getElementById('enterConsole');
  if (!btn) return;

  // 1) Hide the console UI while on the splash
  var style = document.createElement('style');
  style.id = 'splash-hide-console';
  style.textContent =
  'body.splash-mode #cs-console{display:none!important} ' +
  'body.splash-mode .cs-tabs{display:none!important} ' +
  'body.splash-mode .console-btn:not(#enterConsole){display:none!important}';
  document.head.appendChild(style);
  document.body.classList.add('splash-mode');

  // 2) On click, reveal the console and scroll to it
  if (btn.tagName !== 'A') {
  btn.addEventListener('click', function (e) {
    e.preventDefault();
    document.body.classList.remove('splash-mode');
    var cs = document.getElementById('cs-console');
    if (cs && cs.scrollIntoView) cs.scrollIntoView({ behavior: 'smooth', block: 'start' });
  });
})();
</script>
<script>
/* Re-enter: if ?enter=1 is present, programmatically click the existing Enter button */
(function () {
  if (new URLSearchParams(location.search).get('enter') !== '1') return;
  window.addEventListener('DOMContentLoaded', function () {
    document.getElementById('enterConsole')?.click();
    // ensure the console is in view
    const cs = document.getElementById('cs-console');
    cs?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  });
})();
</script>
<script>
/* Force-bind any "close / X" control inside #cs-console to exit.html */
(function () {
  var CS_ID = 'cs-console';
  var DEST = 'exit.html';

  function isCloseLike(el) {
    if (!el) return false;
    var label = ((el.getAttribute && (el.getAttribute('aria-label') || el.getAttribute('data-action'))) || '') +
                ' ' + (el.id || '') +
                ' ' + (el.className || '') +
                ' ' + ((el.textContent || '').trim());
    return /close|×|exit/i.test(label);
  }

  function rebind(root) {
    if (!root) return;
    var nodes = root.querySelectorAll('a,button,[role="button"],[data-action],[aria-label]');
    nodes.forEach(function (el) {
      if (el.closest('.cs-tile')) return;
      if (!isCloseLike(el)) return;

      // Remove any existing behavior and force our exit
      try { el.removeAttribute('href'); } catch(e){}
      try { el.onclick = null; } catch(e){}
      el.addEventListener('click', function (ev) {
        ev.preventDefault(); ev.stopPropagation();
        window.location.assign(DEST);
      }, true); // capture to run before other handlers
    });
  }

  function arm() {
    var cs = document.getElementById(CS_ID);
    if (!cs) return;

    // Rebind now…
    rebind(cs);

    // …and keep re-binding briefly to catch late-renders
    var count = 0, max = 20;
    var tick = setInterval(function () {
      rebind(cs);
      if (++count >= max) clearInterval(tick);
    }, 150);

    // Also observe for DOM changes inside the console
    var mo = new MutationObserver(function () { rebind(cs); });
    mo.observe(cs, { subtree: true, childList: true, attributes: true });
    // Stop after a while to avoid running forever
    setTimeout(function(){ try{ mo.disconnect(); }catch(e){} }, 5000);
  }

  // Arm on load and whenever the Enter Console button is pressed
  window.addEventListener('load', arm);
  document.getElementById('enterConsole')?.addEventListener('click', function () {
    setTimeout(arm, 0);
  });
})();
</script>

<script>
(function(){
  // Show the overlay on every re-entry from exit.html
  if (new URLSearchParams(location.search).get('enter') !== '1') return;

  // Overlay UI
  var o = document.createElement('div');
  o.id = 'fs-overlay';
  o.style.cssText = 'position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.55);z-index:99999';
  o.innerHTML =
    '<div style="background:#111;color:#fff;padding:16px 20px;border-radius:14px;box-shadow:0 8px 28px rgba(0,0,0,.35);font:600 16px system-ui;text-align:center;">' +
      '<div style="margin-bottom:10px;font-weight:800;">Best view is Full Screen</div>' +
      '<div style="display:flex;gap:8px;justify-content:center">' +
        '<button id="fs-go" style="padding:10px 14px;border-radius:12px;background:#fff;color:#111;font-weight:700">Go Full Screen</button>' +
        '<button id="fs-skip" style="padding:10px 14px;border-radius:12px;background:transparent;border:1px solid rgba(255,255,255,.6);color:#fff">Skip</button>' +
      '</div>' +
    '</div>';
  document.body.appendChild(o);

  function close(){ try{o.remove();}catch(e){} }

  // Go Full Screen
  document.getElementById('fs-go').addEventListener('click', function(e){
    e.preventDefault();
    var el = document.documentElement;
    var req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen || el.mozRequestFullScreen;
    if (req) {
      Promise.resolve(req.call(el)).catch(function(){ alert('Press F11 to enter full screen.'); }).finally(close);
    } else {
      alert('Press F11 to enter full screen (or “Add to Home Screen” on iPhone).');
      close();
    }
  });

  // Skip
  document.getElementById('fs-skip').addEventListener('click', function(e){
    e.preventDefault();
    close();
  });
})();
</script>
<script>
(() => {
  // Capture clicks anywhere on the page before other handlers.
  document.addEventListener('click', (e) => {
    const btnInfo = findFsButton(e.target);
    if (!btnInfo) return;

    // Stop any other handlers from interfering.
    e.preventDefault();
    e.stopImmediatePropagation();

    if (btnInfo.type === 'go') {
      // Remove the prompt FIRST so nothing blocks interaction…
      closeFsPrompt();
      // …then request fullscreen synchronously in the same user gesture.
      const root = document.documentElement;
      const req = root.requestFullscreen || root.webkitRequestFullscreen ||
                  root.mozRequestFullScreen || root.msRequestFullscreen;
      try { if (req) req.call(root); } catch (_) {}
    } else {
      // Skip
      closeFsPrompt();
    }
  }, true); // capture=true

  function findFsButton(target){
    // Walk up from the click target to catch buttons or button-like elements.
    for (let n = target; n && n !== document.body; n = n.parentElement) {
      if (!(n.matches && (n.matches('button, a, [role="button"]') || n.tabIndex >= 0))) continue;
      const label = (n.textContent || '').trim();
      if (/^Go Full Screen$/i.test(label) || /Go\s*Full\s*Screen/i.test(label)) return {el:n, type:'go'};
      if (/^Skip$/i.test(label)) return {el:n, type:'skip'};
    }
    return null;
  }

  function closeFsPrompt(){
    // Hide/remove common overlay wrappers and the card itself.
    const candidates = [
      '#cs-fs-prompt', '#cs-fs-prompt-console', '.fs-prompt', '.fs-modal',
      '.modal', '.overlay', '[data-modal]', '[role="dialog"]'
    ];
    const nodes = Array.from(document.querySelectorAll(candidates.join(',')));
    // If none matched, try removing any fixed, high-z overlay that contains our text.
    if (!nodes.length) {
      const all = Array.from(document.querySelectorAll('body > *'));
      all.forEach(el => {
        const cs = getComputedStyle(el);
        if (cs.position === 'fixed' && (cs.zIndex === 'auto' || +cs.zIndex >= 1000)) {
          if (/Best view is Full Screen/i.test(el.textContent || '')) nodes.push(el);
        }
      });
    }
    nodes.forEach(el => { el.style.display = 'none'; try { el.remove(); } catch(_) {} });
    // Ensure page is interactive again
    document.body.style.pointerEvents = '';
  }

  // Safety: if already in fullscreen, ensure no prompt lingers.
  const isFS = () => document.fullscreenElement || document.webkitFullscreenElement;
  if (isFS()) closeFsPrompt();
})();
</script>

</body>
</html>















