<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="dns-prefetch" href="//portal.conciergesync.ai">
  <link rel="preconnect" href="https://portal.conciergesync.ai" crossorigin>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ConciergeSync™ Beta Access</title>
  <style>
    :root {
      --card: #fff;
      --ink: #0f172a;
      --muted: #475569;
      --bg: #f6f7fb;
      --accent: #111;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      line-height: 1.6;
    }

    .container { max-width: 880px; margin: 40px auto; padding: 0 20px; }

    .card {
      background: var(--card);
      border: 1px solid #e6eaf0;
      border-radius: 16px;
      box-shadow: 0 6px 24px rgba(15, 23, 42, 0.06);
      padding: 28px;
      margin-bottom: 24px;
    }

    h1 { font-size: 34px; line-height: 1.2; text-align: center; margin-bottom: 8px; }
    h2 { font-size: 22px; margin: 18px 0; text-align: center; }
    h3 { font-size: 18px; margin: 16px 0 10px; }

    p, li { color: var(--muted); }
    ul { margin: 8px 0 0 24px; }

    .centered { text-align: center; }

    .cta-button {
      display: inline-block;
      padding: 14px 24px;
      border-radius: 12px;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      text-decoration: none;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }
    .cta-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.18);
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Hero Card -->
    <div class="card">
      <h1>Welcome to ConciergeSync™</h1>
      <p class="centered">Your personal travel rewards strategist — earn, manage, and redeem points with clarity.</p>
    </div>

    <!-- Why / Role / Value -->
    <div class="section">
      <div class="card">
        <h2>Why We’re Inviting Beta Users</h2>
        <p style="margin:0 0 12px;color:#444;">
          <strong>ConciergeSync™ turns confusing points & miles rules into clear, dollar-value decisions.</strong>
          But to make it rock-solid, we need real travelers and real itineraries—not lab data.
        </p>
        <p style="margin:0 0 12px;color:#444;">
          We built ConciergeSync™ because the world of points and miles is broken for most people.
          The best rewards, the biggest wins, the true premium experiences — they’re hidden behind complexity,
          endless fine print, and hours of research.
        </p>
        <p style="margin:0 0 12px;color:#444;">
          Most platforms either give you generic advice or try to sell you into their partners.
          <strong>ConciergeSync is different.</strong> We’re creating a tool that thinks like a strategist,
          works like your personal travel concierge, and is completely on your side — no kickbacks,
          no fluff, just maximizing <em>your</em> value.
        </p>
        <p style="margin:0 0 20px;color:#444;">
          You’re here at the very beginning, helping us fine-tune this so it becomes the go-to tool for travelers
          who want the best without wasting time. <strong>The feedback you share today will literally shape what
          ConciergeSync becomes tomorrow.</strong>
        </p>

        <h3 style="margin:12px 0 8px;">Your Role as a Beta User Client (BUC)</h3>
        <ul style="margin:0 0 14px 22px;">
          <li><strong>Onboard (5–7 min):</strong> share your travel goals and programs.</li>
          <li><strong>Explore ConciergeSync™ as it evolves:</strong> we’ll invite you to test features as they’re released and sanity-check how they work.</li>
          <li><strong>Give quick feedback:</strong> if something’s confusing or off, reply to our 2–3 min prompts (we’ll ping you).</li>
        </ul>

        <h3 style="margin:8px 0 8px;">How This Helps ConciergeSync™</h3>
        <ul style="margin:0 0 14px 22px;">
          <li>Validate our true-cost math (fees, surcharges, effective miles burned).</li>
          <li>Surface airline/partner quirks (phantom space, mixed cabins, transfer timing).</li>
          <li>Prioritize the roadmap around what actually saves you time or money.</li>
          <li>Harden reliability across devices, emails, and real booking flows.</li>
        </ul>

        <h3 style="margin:8px 0 8px;">What You Get for Helping Us Build ConciergeSync™</h3>
        <ul style="margin:0 0 6px 22px;">
          <li><strong>Lifetime access</strong> — all premium upgrades included.*</li>
          <li>Early access to new features & partner integrations.</li>
          <li>Priority support and a direct line to the team.</li>
        </ul>
        <p style="margin:10px 0 0;color:#777;font-size:.9rem;">
          *Lifetime access limited to one account per user. No bank logins required; you can opt out anytime.
        </p>
      </div>
    </div>

    <!-- CTA Button -->
    <div class="centered" style="margin-top: 40px;">
      <h2>Ready to join the beta?</h2>
      <a href="/beta/02-agree.html" class="cta-button">Begin Your ConciergeSync™ Journey</a>
    </div>
  </div>

<!-- Pre-warm the portal to avoid cold starts -->
<script>
(function () {
  try {
    var img = new Image();
    img.referrerPolicy = 'no-referrer';
    img.src = 'https://portal.conciergesync.ai/health?ts=' + Date.now();
  } catch (e) {}
})();
</script>

<!-- ============= CONSOLE BACKDROP + FULLSCREEN CONTROLS ============= -->
<!-- Controls -->
<button id="enterConsole" class="console-btn">Enter Console</button>
<button id="exitConsole" class="console-exit" hidden aria-label="Exit Console">×</button>

<!-- Backdrop layers (sit behind your glass tiles) -->
<div id="csBackdrop" class="backdrop">
  <div class="backdrop-image" id="backdropImage"></div>
  <div class="backdrop-overlay" id="backdropOverlay"></div>
</div>

<style id="cs-console-styles">
  :root{
    /* Theme vars */
    --bg-brightness: 1.15;   /* base lift */
    --bg-contrast: 1.05;
    --overlay: 0.28;         /* auto-tuned per image */
    --overlay-grad-top: rgba(0,0,0,0.35);
    --overlay-grad-bottom: rgba(0,0,0,0.55);
    --vh: 100vh;             /* fixed on iOS */
    --z-ui: 4000;            /* ensure buttons sit above your tiles */

    /* Calm motion vars — single source of truth */
    --cs-time: 640ms;                               /* general motion */
    --cs-time-out: 900ms;                           /* dismiss/exit slower */
    --cs-ease: cubic-bezier(.22, 1, .36, 1);        /* mellow ease-out */

    /* Backdrop reveal */
    --bg-blur: 6px;          /* start slightly soft */
    --bg-scale: 1.03;        /* start slightly zoomed */
  }

  /* Respect reduced motion users */
  @media (prefers-reduced-motion: reduce){
    :root{
      --cs-time: 0ms;
      --cs-time-out: 0ms;
    }
  }

  /* Backdrop fills the viewport and lives under your content */
  .backdrop{
    position: fixed;
    inset: 0;
    width: 100%;
    height: var(--vh);
    overflow: hidden;
    z-index: 0;
  }
  .backdrop-image{
    position: absolute;
    inset: 0;
    background-position: center center;
    background-size: cover;
    filter: brightness(var(--bg-brightness)) contrast(var(--bg-contrast)) blur(var(--bg-blur));
    transform: scale(var(--bg-scale)) translateZ(0); /* promote to its own layer */
    will-change: transform, opacity, filter;
    transition: opacity 600ms ease, transform 900ms ease, filter 900ms ease;
    opacity: 0; /* start hidden */
  }
  .backdrop-overlay{
    position: absolute;
    inset: 0;
    pointer-events: none;
    background:
      linear-gradient(to bottom,
        var(--overlay-grad-top),
        var(--overlay-grad-bottom));
    opacity: var(--overlay);
    transition: opacity 220ms ease;
  }

  /* Console buttons */
  .console-btn{
    position: fixed;
    bottom: 24px;
    right: 24px;
    z-index: var(--z-ui);
    padding: 12px 16px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.35);
    background: rgba(20,20,20,0.45);
    backdrop-filter: blur(8px) saturate(1.1);
    color: #fff;
    font-weight: 600;
    cursor: pointer;
  }
  .console-btn:hover{ background: rgba(20,20,20,0.6); }

  .console-exit{
    position: fixed;
    top: 18px;
    right: 18px;
    z-index: var(--z-ui);
    width: 40px; height: 40px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.35);
    background: rgba(20,20,20,0.45);
    color: #fff;
    font-size: 28px; line-height: 36px;
    text-align: center;
    cursor: pointer;
    backdrop-filter: blur(8px) saturate(1.1);
  }
  .console-exit:hover{ background: rgba(20,20,20,0.6); }

  /* Pseudo-fullscreen on iOS */
  .pseudo-fullscreen{
    position: fixed;
    inset: 0;
    width: 100%;
    height: var(--vh);
    overflow: hidden;
    background: #000;
  }

  /* When in console mode, hide the Enter button, show Exit */
  .in-console #enterConsole{ display: none; }
  .in-console #exitConsole{ display: inline-block; }

  /* Immersive console mode */
  .in-console .container {
    opacity: 0;
    pointer-events: none;
    transition: opacity 250ms ease;
  }

  /* Backdrop reveal when console enters */
  .in-console .backdrop-image { opacity: 1; }
  .in-console{
    --bg-blur: 0px;
    --bg-scale: 1.00;
  }

  /* Ensure the close button stays readable */
  .in-console .console-exit {
    box-shadow: 0 2px 10px rgba(0,0,0,.35);
    border-color: rgba(255,255,255,.5);
  }
</style>

<script id="cs-console-script">
(function(){
  // ====== CONFIG: add/adjust your images here ======
  const IMAGES = ['/beta/assets/bg/dfw-hero.jpg'];

  // ====== Helpers ======
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  function setVhVar(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh*100}px`);
  }
  setVhVar();
  window.addEventListener('resize', setVhVar);

  function pickImage(){
    const last = Number(localStorage.getItem('last_bg_idx') ?? '-1');
    let idx = Math.floor(Math.random() * IMAGES.length);
    if (IMAGES.length > 1 && idx === last) idx = (idx + 1) % IMAGES.length;
    localStorage.setItem('last_bg_idx', String(idx));
    return IMAGES[idx];
  }

  function preload(src){
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = src;
    return img;
  }

  function estimateLuminance(imgEl){
    try{
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const w = canvas.width = 64;
      const h = canvas.height = 64;
      ctx.drawImage(imgEl, 0, 0, w, h);
      const data = ctx.getImageData(0,0,w,h).data;
      let sum = 0, count = 0;
      for(let i=0;i<data.length;i+=4){
        const r = data[i], g = data[i+1], b = data[i+2];
        const y = 0.2126*r + 0.7152*g + 0.0722*b; // Rec.709
        sum += y; count++;
      }
      return sum / count; // 0..255
    }catch(e){
      return 140; // safe mid if cross-origin blocks canvas
    }
  }

  function setOverlayForLuma(luma){
    // brighter image => stronger overlay
    const t = Math.min(1, Math.max(0, (luma - 110) / (220 - 110)));
    const opacity = 0.22 + (0.42 - 0.22)*t; // 0.22..0.42
    document.documentElement.style.setProperty('--overlay', opacity.toFixed(3));
  }

  // ====== Apply background ======
  const backdropImage = document.getElementById('backdropImage');
  const chosenSrc = pickImage();
  const img = preload(chosenSrc);
  img.onload = () => {
    backdropImage.style.backgroundImage = `url("${chosenSrc}")`;
    setOverlayForLuma(estimateLuminance(img));
  };

  // ====== Fullscreen / Console Mode ======
  const enterBtn = document.getElementById('enterConsole');
  const exitBtn  = document.getElementById('exitConsole');

  function enterConsole(){
    document.body.classList.add('in-console');
    const rootEl = document.documentElement;
    if (!isIOS && rootEl.requestFullscreen) {
      rootEl.requestFullscreen()
        .then(()=>{ exitBtn.hidden = false; })
        .catch(()=>{
          document.documentElement.classList.add('pseudo-fullscreen');
          exitBtn.hidden = false;
        });
    } else {
      document.documentElement.classList.add('pseudo-fullscreen');
      exitBtn.hidden = false;
    }
  }

  function exitConsole(){
    document.body.classList.remove('in-console');
    exitBtn.hidden = true;
    document.documentElement.classList.remove('pseudo-fullscreen');
    if (document.fullscreenElement) document.exitFullscreen();
  }

  enterBtn.addEventListener('click', enterConsole);
  exitBtn.addEventListener('click', exitConsole);
  window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') exitConsole(); });
})();
</script>
<!-- ========================== /END CONSOLE BLOCK ========================== -->

<!-- ===================== TILE CONSOLE (centered, sliding, swipe-to-dismiss) ===================== -->
<div id="cs-console">
  <!-- Tabs -->
  <div class="cs-tabs" aria-label="Console Tabs">
    <button class="cs-tab" data-key="overview">Overview</button>
    <button class="cs-tab" data-key="itinerary">Itinerary</button>
    <button class="cs-tab" data-key="values">Value Calc</button>
  </div>

  <!-- Tiles area -->
  <div id="cs-tiles" class="cs-tiles" aria-live="polite">
  </div>
</div>

<style>
  /* Layout */
  #cs-console{
    position: absolute; inset: 0;
    display: grid; grid-template-rows: auto 1fr;
    padding: 24px; pointer-events: auto;
    z-index: 10; /* keep this above backdrop */
  }

  /* Tabs */
  .cs-tabs{
    display: flex; justify-content: center; gap: 10px;
    padding: 10px 12px;
    backdrop-filter: blur(8px) saturate(1.1);
    background: rgba(20,20,20,.3);
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,.25);
    width: max-content; margin: 0 auto 14px;
  }
  .cs-tab{
    padding: 10px 14px; border-radius: 10px;
    color: #fff; background: rgba(255,255,255,.06);
    border: 1px solid rgba(255,255,255,.18);
    cursor: pointer; font-weight: 600;
  }
  .cs-tab:hover{ background: rgba(255,255,255,.12); }

  /* Tiles grid: center rows, wrap when needed */
  .cs-tiles{
    position: relative;
    display: grid;
    grid-auto-flow: row dense;
    grid-auto-rows: 1fr;
    grid-template-columns: repeat(auto-fit, minmax(320px, 420px));
    gap: 18px;
    justify-content: center;   /* centering magic */
    align-content: start;
    height: 100%;
    overflow: auto;
    padding: 6px;
  }
  /* Center a single tile perfectly */
  .cs-tiles.single{
    grid-template-columns: minmax(360px, 520px); /* exactly one column */
    justify-content: center;
  }

  /* Tile (glass) */
  .cs-tile{
    /* perf hints */
    will-change: transform, opacity;
    transform: translateZ(0);

    /* look */
    background: rgba(255,255,255,.12);
    border: 1px solid rgba(255,255,255,.28);
    border-radius: 18px;
    box-shadow: 0 10px 30px rgba(0,0,0,.18);
    backdrop-filter: blur(12px) saturate(1.2);
    color: #f5f7fb;

    /* layout */
    display: grid; 
    grid-template-rows: auto 1fr;
    min-height: 260px; 
    max-height: 65vh;
    overflow: hidden;

    /* entry animation (soft pop) */
    transform: translateY(24px) scale(.94);
    opacity: 0;
    animation: cs-pop var(--cs-time) var(--cs-ease) forwards;

    /* allow horizontal swipe on touch */
    touch-action: pan-y;
  }

  /* Focused tile: a touch brighter with a soft lift */
  .cs-tile.is-focused{
    box-shadow: 0 16px 44px rgba(0,0,0,.28),
                0 0 0 1px rgba(255,255,255,.20) inset;
    backdrop-filter: blur(12px) saturate(1.25);
    transform: translateZ(0);
  }

  /* While FLIP is running or you're swiping, lighten effects for smoothness */
  .cs-tile.moving,
  .cs-tile.cs-swiping{
    backdrop-filter: blur(8px) saturate(1.1);
    box-shadow: 0 8px 22px rgba(0,0,0,.16);
  }

  /* Smooth swipe-away when we commit the dismiss (calm timing) */
  .cs-tile.cs-dismissing{
    transition: transform var(--cs-time-out) var(--cs-ease),
                opacity   var(--cs-time-out) var(--cs-ease);
    opacity: 0;
  }
  /* === Free-mode tile positioning === */
  .cs-free .cs-tile {
  position: absolute;
  transform: translate(var(--x, 0), var(--y, 0));
  will-change: transform, box-shadow;
  touch-action: none; /* keeps drag under the finger on touch */

  /* smooth when snapping/centering; JS sets 'none' during active drag */
 transition: transform 480ms cubic-bezier(.22, 1, .36, 1), 
            box-shadow 320ms cubic-bezier(.22, 1, .36, 1);
  }
  }  /* closes .cs-free .cs-tile  (line 506) */

/* Tiny settle pulse after a move */
@keyframes cs-land {
  0%   { transform: translate(var(--x, 0), var(--y, 0)) scale(1.015); }
  60%  { transform: translate(var(--x, 0), var(--y, 0)) scale(0.995); }
  100% { transform: translate(var(--x, 0), var(--y, 0)) scale(1); }
}
.cs-free .cs-tile.cs-landing {
  animation: cs-land 420ms cubic-bezier(.22, 1, .36, 1);
}

/* Entrance pop */
@keyframes cs-pop {
  0%   { opacity: 0; transform: translateY(24px) scale(.94); }
  60%  { opacity: 1; transform: translateY(0)    scale(1.02); }
  100% { opacity: 1; transform: translateY(0)    scale(1); }
}

/* Close (X) animation */
.cs-exit{
  animation: cs-exit var(--cs-time) var(--cs-ease) forwards;
}
@keyframes cs-exit{
  to { opacity: 0; transform: translateY(8px) scale(.96); }
}

  .cs-tile-head{
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 14px; background: rgba(0,0,0,.18);
    border-bottom: 1px solid rgba(255,255,255,.18);
  }
  .cs-tile-head h4{ margin: 0; font-size: 15px; font-weight: 700; letter-spacing:.2px; }
  .cs-close{
    width: 30px; height: 30px; border-radius: 8px;
    background: rgba(255,255,255,.12);
    color: #fff; border: 1px solid rgba(255,255,255,.25);
    cursor: pointer; font-size: 18px; line-height: 28px; text-align:center;
  }
  .cs-close:hover{ background: rgba(255,255,255,.2); }
  .cs-tile-body{ padding: 14px; overflow: auto; }

  /* Free-mode: tiles are freely placed and draggable (JS will toggle .cs-free) */
#cs-console.cs-free .cs-tiles { position: relative; }

#cs-console.cs-free .cs-tile  {
  position: absolute;
  left: var(--x, 0px);
  top:  var(--y, 0px);
  will-change: left, top, transform;
  transition: transform var(--cs-time) var(--cs-ease), box-shadow 180ms ease;
  touch-action: none; /* let our handler capture both X & Y without browser scrolling */
}

  /* Swipe feedback defaults */
  .cs-swiping{ transition: none !important; }
  .cs-tile{ transition: transform 160ms ease, opacity 160ms ease; }

  /* --- TEMP: force taps through overlays to tiles --- */
.cs-overlay,
.cs-scrim,
.cs-glow,
.cs-shadow,
.cs-bling,
[data-overlay],
[aria-hidden="true"]{
  pointer-events: none !important;
}

/* Ensure the tiles themselves can still receive taps */
.cs-tile,
.cs-tile *{
  pointer-events: auto;
}

/* Improve touch behavior on the tap targets */
.cs-tile{
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}

</style>

<script>
(()=>{
  const tabs = document.querySelectorAll('.cs-tab');
  const tilesWrap = document.getElementById('cs-tiles');
    // Always close on X (delegated, so it works for new tiles too)
  tilesWrap.addEventListener('click', (e) => {
    const x = e.target.closest('.cs-close');
    if (!x) return;
    const tile = x.closest('.cs-tile');
    if (tile) closeTile(tile);
  });


  function updateWrapClass(){
    const count = tilesWrap.querySelectorAll('.cs-tile').length;
    tilesWrap.classList.toggle('single', count === 1);
  }

  // ---- FLIP animation helper: smoothly animate tile reordering ----
  function flipAnimate(container, changeDomSync){
    // Respect reduced motion
    const REDUCED = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (REDUCED) { changeDomSync(); return; }

    // 1) measure "first" positions
    const children = Array.from(container.children);
    const first = new Map();
    children.forEach(el => first.set(el, el.getBoundingClientRect()));

    // 2) DOM change (append/reorder/remove)
    changeDomSync();

    // 3) measure "last" and animate first -> last
    const last = new Map();
    Array.from(container.children).forEach(el => last.set(el, el.getBoundingClientRect()));

    last.forEach((rLast, el) => {
      const rFirst = first.get(el);
      if (!rFirst) return; // new element: its own entry animation will handle it
      const dx = rFirst.left - rLast.left;
      const dy = rFirst.top  - rLast.top;
      if (dx || dy) {
        el.style.willChange = 'transform';
        el.style.transition = 'transform 0s';
        el.style.transform = `translate(${dx}px, ${dy}px)`;
        // double RAF so the browser commits the starting transform
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            el.style.transition = 'transform var(--cs-time) var(--cs-ease)';
            el.style.transform = '';
            el.addEventListener('transitionend', () => {
              el.style.transition = '';
              el.style.willChange = '';
            }, { once: true });
          });
        });
      }
    });
  }

  // -------------------------------------------
  // Calm dismiss helper (global to this module)
  // -------------------------------------------
  function calmDismiss(tile, direction = 1){
    const off = (window.innerWidth * 0.5) * direction; // 50vw
    tile.classList.add('cs-dismissing');               // uses --cs-time-out easing
    tile.style.transform = `translateX(${off}px) rotate(${off*0.002}deg)`;
    tile.addEventListener('transitionend', () => {
      tile.remove();
    }, { once: true });
  }

  // Dismiss focused tile on backdrop / outside click with a calm glide
  const consoleEl  = document.getElementById('cs-console');
  const backdropEl = document.querySelector('#csBackdrop, .backdrop');

  function isOutsideConsole(target){
    return consoleEl && !consoleEl.contains(target);
  }

  // Backdrop click/tap
  if (backdropEl) {
    backdropEl.addEventListener('pointerdown', (e) => {
      const active = document.querySelector('.cs-tile.is-focused');
      if (!active) return;
      const dir = (e.clientX >= window.innerWidth/2) ? 1 : -1;
      calmDismiss(active, dir);
    });
  }

  // Generic click-out anywhere outside the console
  window.addEventListener('pointerdown', (e) => {
    if (!isOutsideConsole(e.target)) return;
    const active = document.querySelector('.cs-tile.is-focused');
    if (!active) return;
    const dir = (e.clientX >= window.innerWidth/2) ? 1 : -1;
    calmDismiss(active, dir);
  }, { capture: true });

  // Store open order so selected + current stay centered in row 1
  const openKeys = new Set(); // insertion order matters

  // Map of tile blueprints (you can replace innerHTML per tile)
  const TILE_TEMPLATES = {
    overview: () => `
      <header class="cs-tile-head">
        <h4>Overview</h4>
        <button class="cs-close" aria-label="Close">×</button>
      </header>
      <div class="cs-tile-body">
        <p>Overview content goes here.</p>
      </div>`,
    itinerary: () => `
      <header class="cs-tile-head">
        <h4>Itinerary</h4>
        <button class="cs-close" aria-label="Close">×</button>
      </header>
      <div class="cs-tile-body">
        <p>Trip segments, dates, carriers.</p>
      </div>`,
    values: () => `
      <header class="cs-tile-head">
        <h4>Value Calc</h4>
        <button class="cs-close" aria-label="Close">×</button>
      </header>
      <div class="cs-tile-body">
        <p>CPP, cash vs award, transfer hints.</p>
      </div>`
  };

  // Create/open tile by key
  function openTile(key){
    // if already open, bring it to the "focused pair" (row 1 center)
    const existing = tilesWrap.querySelector(`.cs-tile[data-key="${key}"]`);
    if (existing){
      openKeys.delete(key);
      openKeys.add(key);
      applyOrder();
      updateWrapClass();
      existing.focus({preventScroll:true});
      return;
    }
    // create tile
    const sec = document.createElement('section');
    sec.className = 'cs-tile';
    sec.dataset.key = key;
    sec.innerHTML = (TILE_TEMPLATES[key] || (()=>`
    // TEMP: force the tile visible (skip broken css animation)
    sec.style.opacity = '1';
    sec.style.transform = 'none';
      <header class="cs-tile-head">
        <h4>${key}</h4>
        <button class="cs-close" aria-label="Close">×</button>
      </header>
      <div class="cs-tile-body"><p>${key} tile.</p></div>`))();
    addTileHandlers(sec);
    // TEMP: bypass FLIP — just append so we can SEE it
    tilesWrap.appendChild(sec);
        updateWrapClass();
    return; // stop here for the test
// Center + init drag when in free mode
{
  const consoleEl = document.getElementById('cs-console');
  if (consoleEl && consoleEl.classList.contains('cs-free')) {
    const wrapRect = tilesWrap.getBoundingClientRect();
    const tileRect = sec.getBoundingClientRect();

    const x = tilesWrap.scrollLeft + (wrapRect.width  - tileRect.width)  / 2;
    const y = tilesWrap.scrollTop  + (wrapRect.height - tileRect.height) / 2;

    sec.style.setProperty('--x', `${Math.max(0, x)}px`);
    sec.style.setProperty('--y', `${Math.max(0, y)}px`);

    makeDraggable(sec, tilesWrap);
  }
}

sec.focus({ preventScroll: true });

  }
// ---------- FREE MODE: drag anywhere + swipe-off ----------
function enableFreeMode(){
  const consoleEl = document.getElementById('cs-console');
  const grid = document.getElementById('cs-tiles');
  if (!consoleEl || !grid) return;
  consoleEl.classList.add('cs-free');

  // Freeze each tile where it currently sits (convert grid pos -> absolute)
  const gridRect = grid.getBoundingClientRect();
  Array.from(grid.children).forEach(tile => {
    const r = tile.getBoundingClientRect();
    const x = r.left - gridRect.left + grid.scrollLeft;
    const y = r.top  - gridRect.top  + grid.scrollTop;
    tile.style.setProperty('--x', x + 'px');
    tile.style.setProperty('--y', y + 'px');
    makeDraggable(tile, grid);
  });
}

function makeDraggable(tile, container){
  let sx=0, sy=0, startX=0, startY=0, dx=0, dy=0, dragging=false, lastT=0, vx=0, vy=0;

  const getVar = (name) => {
    const v = getComputedStyle(tile).getPropertyValue(name);
    return parseFloat(v) || 0;
  };

  const onDown = (e) => {
  // 1) Let interactive elements work normally (Close button, links, inputs)
  const tgt = e.target;
  if (
    tgt.closest('.cs-close') ||
    tgt.closest('button') ||
    tgt.closest('a') ||
    tgt.closest('input, textarea, select')
  ) {
    return; // don't start a drag — allow the click to go through
  }

  // 2) Only primary button/pointer should drag
  if ('button' in e && e.button !== 0) return;

  // 3) Start drag
  const p = ('touches' in e) ? e.touches[0] : e;
  e.preventDefault();          // follow finger exactly
  e.stopPropagation();         // avoid old swipe listeners
  dragging = true;
  sx = p.clientX; sy = p.clientY;
  startX = getVar('--x'); startY = getVar('--y');
  dx = dy = 0; vx = vy = 0;
  lastT = performance.now();
  tile.setPointerCapture?.(e.pointerId);
  tile.style.transition = 'none';  // hard-disable transitions while dragging
};


  const onMove = (e) => {
    if (!dragging) return;
    e.preventDefault();
    const p = ('touches' in e) ? e.touches[0] : e;
    dx = p.clientX - sx;
    dy = p.clientY - sy;
    // immediate visual update, batched to the next frame (prevents jank)
if (!tile._raf) {
  tile._raf = requestAnimationFrame(() => {
    tile.style.transform = `translate(${dx}px, ${dy}px) rotate(${dx*0.008}deg)`;
    tile._raf = null;
  });
}

    // simple velocity estimate
    const now = performance.now();
    const dt = Math.max(16, now - lastT);
    vx = (dx - (tile._lastDx || 0)) / dt;
    vy = (dy - (tile._lastDy || 0)) / dt;
    tile._lastDx = dx; tile._lastDy = dy; lastT = now;

    tile.style.transform = `translate(${dx}px, ${dy}px) rotate(${dx*0.008}deg)`;
  };

  const onUp = () => {
    if (!dragging) return;
    dragging = false;

    const newX = startX + dx;
    const newY = startY + dy;
    
    tile.classList.add('cs-landing');
    tile.addEventListener('animationend', () => {
      tile.classList.remove('cs-landing');
    }, { once: true });

    // swipe-off if far or fast enough (mainly horizontal)
    const dismiss = Math.abs(dx) > 160 || (Math.hypot(vx, vy) > 0.8 && Math.abs(dx) > 100);
    if (dismiss){
      const dir = dx >= 0 ? 1 : -1;
      calmDismiss(tile, dir);
    } else {
      tile.style.transition = `transform var(--cs-time) var(--cs-ease)`;
      tile.style.setProperty('--x', Math.max(0, newX) + 'px');
      tile.style.setProperty('--y', Math.max(0, newY) + 'px');
      requestAnimationFrame(() => { tile.style.transform = ''; });
      tile.addEventListener('transitionend', () => {
        tile.style.transition = '';
      }, { once: true });
    }

    tile._lastDx = tile._lastDy = 0;
  };

  // pointer + touch (capture to win over existing handlers)
  tile.addEventListener('pointerdown', onDown, {capture:true});
  window.addEventListener('pointermove', onMove,  {capture:true});
  window.addEventListener('pointerup',   onUp,    {capture:true});

}

  // Maintain centered first row with the last two opened tiles
  function applyOrder(){
    const keys = Array.from(openKeys);
    const focused = keys.slice(-2); // last two opened should sit together, centered
    flipAnimate(tilesWrap, () => {
      focused.forEach(k => {
        const el = tilesWrap.querySelector(`.cs-tile[data-key="${k}"]`);
        if (el) tilesWrap.appendChild(el);
      });
    });
  }

  // Close tile (animated)
  function closeTile(el){
    const key = el.dataset.key;
    el.classList.add('cs-exit');
    el.addEventListener('animationend', () => {
      // Animate the layout change while removing this tile
      flipAnimate(tilesWrap, () => {
        if (openKeys.has(key)) openKeys.delete(key);
        el.remove();
      });
      applyOrder();
      updateWrapClass();
    }, { once: true });
  }

  // Swipe-to-dismiss handlers (calm tuning)
  function addTileHandlers(tile){
    // If we're in free mode, skip attaching the grid-swipe handlers.
// Still wire the X button.
{
  const consoleEl = document.getElementById('cs-console');
  if (consoleEl && consoleEl.classList.contains('cs-free')) {
    tile.querySelector('.cs-close')?.addEventListener('click', () => closeTile(tile));
    return; // prevent conflicting swipe listeners
  }
}

    // close button
    tile.querySelector('.cs-close').addEventListener('click', ()=>closeTile(tile));

    // swipe
    let startX=0, currentX=0, dragging=false;

    const onDown = (e)=>{
      dragging = true;
      startX = (e.touches ? e.touches[0].clientX : e.clientX);
      tile.classList.add('cs-swiping');
    };

    const onMove = (e)=>{
      if(!dragging) return;
      currentX = (e.touches ? e.touches[0].clientX : e.clientX);
      const dx = currentX - startX;
      tile.style.transform = `translateX(${dx}px) rotate(${dx*0.008}deg)`; // calmer rotation
      tile.style.opacity = String(Math.max(0.4, 1 - Math.abs(dx)/600));
    };

    const onUp = () => {
  if (!dragging) return;
  dragging = false;
  tile.classList.remove('cs-swiping');

  const dx = currentX - startX;
  const direction = dx >= 0 ? 1 : -1;
  const DISMISS_DIST = 160; // try 140 if you want easier dismiss

  if (Math.abs(dx) > DISMISS_DIST) {
    // Use the calm glide-off
    calmDismiss(tile, direction);
  } else {
    // Snap back gently
    tile.style.transition = `transform var(--cs-time) var(--cs-ease)`;
    tile.style.transform = '';
    tile.addEventListener('transitionend', () => {
      tile.style.transition = '';
    }, { once: true });
  }
};


    tile.addEventListener('mousedown', onDown);
    tile.addEventListener('touchstart', onDown, {passive:true});
    window.addEventListener('mousemove', onMove);
    window.addEventListener('touchmove', onMove, {passive:true});
    window.addEventListener('mouseup', onUp);
    window.addEventListener('touchend', onUp);
  }

  // Wire tabs — fire immediately on touch/mouse
tabs.forEach((btn) => {
  const onTap = (e) => {
    // prevent the mobile delay / ghost click when it's touch or pen
    if (e.pointerType === 'touch' || e.pointerType === 'pen') e.preventDefault();
    openTile(btn.dataset.key);
  };

  btn.addEventListener('pointerdown', onTap, { passive: false }); // earliest, reliable
  btn.addEventListener('click', (e) => onTap(e));                  // fallback for mouse-only/older
});

  // Ensure the initial tile has handlers
  document.querySelectorAll('.cs-tile').forEach(addTileHandlers);
  updateWrapClass();
  enableFreeMode();
  
})();
</script>
<!-- =================== /END TILE CONSOLE =================== -->
<script>
// Fallback: when a .cs-tab is tapped, force-reveal the panel right after it
document.addEventListener('pointerup', function (e) {
  const btn = e.target.closest('.cs-tab');
  if (!btn) return;

  const tile = btn.closest('.cs-tile');
  const panel = btn.nextElementSibling; // many UIs put the panel right after the tab

  if (tile) tile.classList.add('is-open');

  if (panel) {
    panel.removeAttribute('hidden');
    panel.setAttribute('aria-hidden','false');
    panel.style.display = 'block';
    panel.style.opacity = '1';
    panel.style.maxHeight = '100vh';
    panel.style.visibility = 'visible';
  }
}, true);
</script>

</body>
</html>



















